/*
2019 © Postgres.ai
*/

// Package msgproc provides a service for processing of incoming events.
package msgproc

import (
	"bytes"
	"context"
	"database/sql"
	"encoding/json"
	"fmt"
	"io/ioutil"
	"net/http"
	"strings"
	"time"

	"github.com/hako/durafmt"
	"github.com/pkg/errors"
	"github.com/rs/xid"
	"github.com/sethvargo/go-password/password"
	"gitlab.com/postgres-ai/database-lab/pkg/client/dblabapi/types"
	"gitlab.com/postgres-ai/database-lab/pkg/log"
	"gitlab.com/postgres-ai/database-lab/pkg/models"

	"gitlab.com/postgres-ai/joe/pkg/bot/api"
	"gitlab.com/postgres-ai/joe/pkg/services/usermanager"
	"gitlab.com/postgres-ai/joe/pkg/structs"
)

const QUERY_PREVIEW_SIZE = 400

// HelpMessage defines available commands provided with the help message.
const HelpMessage = "• `explain` — analyze your query (SELECT, INSERT, DELETE, UPDATE or WITH) and generate recommendations\n" +
	"• `plan` — analyze your query (SELECT, INSERT, DELETE, UPDATE or WITH) without execution\n" +
	"• `exec` — execute any query (for example, CREATE INDEX)\n" +
	"• `reset` — revert the database to the initial state (usually takes less than a minute, :warning: all changes will be lost)\n" +
	"• `\\d`, `\\d+`, `\\dt`, `\\dt+`, `\\di`, `\\di+`, `\\l`, `\\l+`, `\\dv`, `\\dv+`, `\\dm`, `\\dm+` — psql meta information commands\n" +
	"• `hypo` — create hypothetical indexes using the HypoPG extension\n" +
	"• `help` — this message\n"

const MsgSessionStarting = "Starting new session...\n"

const MsgSessionForewordTpl = "• Say 'help' to see the full list of commands.\n" +
	"• Sessions are fully independent. Feel free to do anything.\n" +
	"• The session will be destroyed after %s of inactivity.\n" +
	"• EXPLAIN plans here are expected to be identical to production plans.\n" +
	"• The actual timing values may differ from production because actual caches in DB Lab are smaller. " +
	"However, the number of bytes and pages/buffers in plans are identical to production.\n" +
	"\nMade with :hearts: by Postgres.ai. Bug reports, ideas, and merge requests are welcome: https://gitlab.com/postgres-ai/joe \n" +
	"\nJoe version: %s.\nSnapshot data state at: %s."

const SeparatorEllipsis = "\n[...SKIP...]\n"

// Hint messages.
const (
	HintExplain = "Consider using `explain` command for DML statements. See `help` for details."
	HintExec    = "Consider using `exec` command for DDL statements. See `help` for details."
)

const joeUserNamePrefix = "joe_"

// Constants for autogenerated passwords.
const (
	PasswordLength     = 16
	PasswordMinDigits  = 4
	PasswordMinSymbols = 0
)

var hintExplainDmlWords = []string{"insert", "select", "update", "delete", "with"}
var hintExecDdlWords = []string{"alter", "create", "drop", "set"}

// runSession starts a user session if not exists.
func (s *ProcessingService) runSession(ctx context.Context, user *usermanager.User, channelID string) error {
	sMsg := structs.NewMessage(channelID)

	messageText := strings.Builder{}

	if user.Session.Clone != nil {
		return nil
	}

	// Stop clone session if not active.
	s.stopSession(user)

	messageText.WriteString(MsgSessionStarting)
	sMsg.SetText(messageText.String())
	s.messenger.Publish(sMsg)
	messageText.Reset()

	s.messenger.UpdateStatus(sMsg, structs.StatusRunning)

	clone, err := s.createDBLabClone(ctx, user)
	if err != nil {
		s.messenger.Fail(sMsg, err.Error())

		return err
	}

	sMsg.AppendText(getForeword(time.Duration(clone.Metadata.MaxIdleMinutes)*time.Minute,
		s.Config.Version, clone.Snapshot.DataStateAt))
	if err := s.messenger.UpdateText(sMsg); err != nil {

		s.messenger.Fail(sMsg, err.Error())
		return errors.Wrap(err, "failed to append message with a foreword")
	}

	if clone.DB == nil {
		return errors.New("failed to get connection params")
	}

	dblabClone := s.buildDBLabCloneConn(clone.DB)

	db, err := initConn(dblabClone)
	if err != nil {
		return errors.Wrap(err, "failed to init database connection")
	}

	user.Session.ConnParams = dblabClone
	user.Session.Clone = clone
	user.Session.CloneConnection = db

	if s.Config.HistoryEnabled {
		if err := s.createPlatformSession(user, sMsg.ChannelID); err != nil {
			s.messenger.Fail(sMsg, err.Error())
			return err
		}
	}

	sessionID := user.Session.Clone.ID
	if user.Session.PlatformSessionId != "" {
		sessionID = user.Session.PlatformSessionId
	}

	sMsg.AppendText(fmt.Sprintf("Session started: `%s`", sessionID))
	if err := s.messenger.UpdateText(sMsg); err != nil {
		s.messenger.Fail(sMsg, err.Error())
		return errors.Wrap(err, "failed to append message about session start")
	}

	if err := s.messenger.OK(sMsg); err != nil {
		log.Err(err)
	}

	return nil
}

func (s *ProcessingService) buildDBLabCloneConn(DBParams *models.Database) structs.Clone {
	return structs.Clone{
		Name:     s.Config.DBLab.DBName,
		Host:     DBParams.Host,
		Port:     DBParams.Port,
		Username: DBParams.Username,
		Password: DBParams.Password,
		SSLMode:  s.Config.DBLab.SSLMode,
	}
}

func initConn(dblabClone structs.Clone) (*sql.DB, error) {
	db, err := sql.Open("postgres", dblabClone.ConnectionString())
	if err != nil {
		log.Err("DB connection:", err)
		return nil, err
	}

	if err := db.PingContext(context.TODO()); err != nil {
		return nil, errors.WithStack(err)
	}

	return db, nil
}

// createDBLabClone creates a new clone.
func (s *ProcessingService) createDBLabClone(ctx context.Context, user *usermanager.User) (*models.Clone, error) {
	pwd, err := password.Generate(PasswordLength, PasswordMinDigits, PasswordMinSymbols, false, true)
	if err != nil {
		return nil, errors.Wrap(err, "failed to generate a password to a new clone")
	}

	clientRequest := types.CloneCreateRequest{
		ID:        "joe-" + xid.New().String(),
		Project:   s.Config.ApiProject,
		Protected: false,
		DB: &types.DatabaseRequest{
			Username: joeUserNamePrefix + user.UserInfo.Name,
			Password: pwd,
		},
	}

	clone, err := s.DBLab.CreateClone(ctx, clientRequest)
	if err != nil {
		return nil, errors.Wrap(err, "failed to create a new clone")
	}

	if clone.Snapshot == nil {
		clone.Snapshot = &models.Snapshot{}
	}

	clone.DB.Password = pwd

	return clone, nil
}

// createPlatformSession starts a new platform session.
func (s *ProcessingService) createPlatformSession(user *usermanager.User, channelID string) error {
	sessionID, err := s.ApiCreatePlatformSession(user.UserInfo.ID, user.UserInfo.Name, channelID)
	if err != nil {
		log.Err("API: Create platform session:", err)

		if err := s.destroySession(user); err != nil {
			return errors.Wrap(err, "failed to stop a user session")
		}

		return errors.Wrap(err, "failed to create a platform session")
	}

	user.Session.PlatformSessionId = sessionID

	return nil
}

// ApiCreatePlatformSession makes an HTTP request to create a new platform session.
func (s *ProcessingService) ApiCreatePlatformSession(uid string, username string, channel string) (string, error) {
	log.Dbg("API: Create session")

	reqData, err := json.Marshal(&api.ApiSession{
		ProjectName:   s.Config.ApiProject,
		AccessToken:   s.Config.ApiToken,
		SlackUid:      uid,
		SlackUsername: username,
		SlackChannel:  channel,
	})
	if err != nil {
		return "", err
	}

	resp, err := http.Post(s.Config.ApiUrl+"/rpc/joe_session_create", "application/json", bytes.NewBuffer(reqData))
	if err != nil {
		return "", err
	}

	bodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return "", err
	}

	respData := api.ApiCreateSessionResp{}
	err = json.Unmarshal(bodyBytes, &respData)
	if err != nil {
		return "", err
	}

	if len(respData.Code) > 0 || len(respData.Message) > 0 {
		return "", errors.Errorf("error: %v", respData)
	}

	log.Dbg("API: Create session success", respData.SessionId)
	return fmt.Sprintf("%d", respData.SessionId), nil
}

func getForeword(idleDuration time.Duration, version, dataStateAt string) string {
	duration := durafmt.Parse(idleDuration.Round(time.Minute))
	return fmt.Sprintf(MsgSessionForewordTpl, duration, version, dataStateAt)
}
